{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport * as R from 'ramda';\nimport { GatekeeperRecordState, GatewayStatus } from '../types';\nimport logger from '../logger';\nimport useWalletHooks from './useWalletHooks';\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    case 'getGatekeeperRecord':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: GatewayStatus.CHECKING,\n        gatekeeperRecordState: undefined\n      });\n\n    case 'getGatekeeperRecord_failure':\n      return Object.assign(Object.assign({}, state), {\n        gatekeeperRecordState: action.gatekeeperRecord.state\n      });\n\n    case 'getGatekeeperRecord_success':\n      return Object.assign(Object.assign({}, state), {\n        gatekeeperRecordState: action.gatekeeperRecord.state,\n        civicPass: Object.assign(Object.assign({}, state.civicPass), {\n          requestPayload: action.gatekeeperRecord.payload\n        })\n      });\n\n    case 'getGatekeeperRecord_location_not_supported':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: GatewayStatus.LOCATION_NOT_SUPPORTED,\n        gatekeeperRecordState: action.gatekeeperRecord.state,\n        civicPass: Object.assign(Object.assign({}, state.civicPass), {\n          requestPayload: action.gatekeeperRecord.payload\n        })\n      });\n\n    case 'getGatekeeperRecord_issued_location_not_supported':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: GatewayStatus.LOCATION_NOT_SUPPORTED,\n        gatekeeperRecordState: action.gatekeeperRecord.state,\n        civicPass: Object.assign(Object.assign({}, state.civicPass), {\n          requestPayload: action.gatekeeperRecord.payload\n        })\n      });\n\n    case 'getGatekeeperRecord_not_found':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: GatewayStatus.NOT_REQUESTED,\n        gatekeeperRecordState: action.gatekeeperRecord.state\n      });\n\n    default:\n      return state;\n  }\n};\n\nconst useGetGatekeeperRecord = (_ref, state, dispatch) => {\n  let {\n    wallet,\n    gatekeeperClient,\n    httpConfig\n  } = _ref;\n  const {\n    expectWalletConnected\n  } = useWalletHooks(wallet, state, dispatch);\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger.debug(`[useGetGatekeeperRecord] ${message}`, obj);\n  };\n\n  const {\n    gatewayToken,\n    gatekeeperNetworkAddress\n  } = state;\n\n  const dispatchFetch = () => ({\n    type: 'getGatekeeperRecord'\n  });\n\n  const dispatchFailure = () => ({\n    type: 'getGatekeeperRecord_failure',\n    gatekeeperRecord: {\n      state: GatekeeperRecordState.SERVER_FAILURE,\n      payload: undefined\n    }\n  });\n\n  const dispatchSuccess = record => ({\n    type: 'getGatekeeperRecord_success',\n    gatekeeperRecord: record\n  });\n\n  const dispatchLocationNotSupported = record => ({\n    type: 'getGatekeeperRecord_location_not_supported',\n    gatekeeperRecord: record\n  });\n\n  const dispatchIssuedLocationNotSupported = record => ({\n    type: 'getGatekeeperRecord_issued_location_not_supported',\n    gatekeeperRecord: record\n  });\n\n  const dispatchRecordNotFound = record => ({\n    type: 'getGatekeeperRecord_not_found',\n    gatekeeperRecord: record\n  });\n\n  const getAction = gatekeeperRecordState => {\n    const actions = {\n      [GatekeeperRecordState.REQUESTED]: () => dispatchSuccess(gatekeeperRecordState),\n      [GatekeeperRecordState.ISSUED]: () => dispatchSuccess(gatekeeperRecordState),\n      [GatekeeperRecordState.ISSUED_EXPIRED]: () => dispatchSuccess(gatekeeperRecordState),\n      [GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING]: () => dispatchSuccess(gatekeeperRecordState),\n      [GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED]: () => dispatchIssuedLocationNotSupported(gatekeeperRecordState),\n      [GatekeeperRecordState.LOCATION_NOT_SUPPORTED]: () => dispatchLocationNotSupported(gatekeeperRecordState),\n      [GatekeeperRecordState.NOT_REQUESTED]: () => dispatchRecordNotFound(gatekeeperRecordState)\n    };\n    return actions[gatekeeperRecordState.state];\n  };\n  /**\n   * Check to see if there is getGatekeeperRecord and dispatch actions based on the state of the record.\n   * If the service call fails dispatch a failure.\n   */\n\n\n  const dispatchGatekeeperRecord = async () => {\n    const walletAddress = expectWalletConnected();\n    logDebug('Fetching Gatekeeper record');\n    dispatch(dispatchFetch());\n\n    try {\n      const record = await gatekeeperClient().getGatekeeperRecordWithPayload(walletAddress.publicKey);\n      logDebug('Gatekeeper record response state: ', GatekeeperRecordState[record.state]);\n      const action = getAction(record);\n\n      if (!action) {\n        logger.error('Cannot dispatch action for invalid Gatekeeper Record State.', {\n          record\n        });\n        return;\n      }\n\n      dispatch(action());\n    } catch (error) {\n      logger.error('Failed to fetch Gatekeeper record', error);\n      dispatch(dispatchFailure());\n      throw error;\n    }\n  };\n\n  const useHttpConfigRef = newHttpConfig => {\n    const ref = useRef(); // We have to perform a deep equality check, otherwise useEffect will run every time the httpConfig object reference changes.\n\n    if (!R.equals(newHttpConfig, ref.current)) {\n      ref.current = newHttpConfig;\n    }\n\n    return ref.current;\n  };\n\n  useEffect(() => {\n    if (!wallet || !wallet.publicKey) return;\n    dispatchGatekeeperRecord();\n  }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.state, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress, useHttpConfigRef(httpConfig)]);\n  return {\n    dispatchGatekeeperRecord\n  };\n};\n\nexport default useGetGatekeeperRecord;","map":{"version":3,"sources":["F:/SitePortfolio/skillfond/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useGatekeeperRecord.js"],"names":["useEffect","useRef","R","GatekeeperRecordState","GatewayStatus","logger","useWalletHooks","reducer","state","action","type","Object","assign","gatewayStatus","CHECKING","gatekeeperRecordState","undefined","gatekeeperRecord","civicPass","requestPayload","payload","LOCATION_NOT_SUPPORTED","NOT_REQUESTED","useGetGatekeeperRecord","dispatch","wallet","gatekeeperClient","httpConfig","expectWalletConnected","logDebug","message","obj","debug","gatewayToken","gatekeeperNetworkAddress","dispatchFetch","dispatchFailure","SERVER_FAILURE","dispatchSuccess","record","dispatchLocationNotSupported","dispatchIssuedLocationNotSupported","dispatchRecordNotFound","getAction","actions","REQUESTED","ISSUED","ISSUED_EXPIRED","ISSUED_EXPIRY_APPROACHING","ISSUED_LOCATION_NOT_SUPPORTED","dispatchGatekeeperRecord","walletAddress","getGatekeeperRecordWithPayload","publicKey","error","useHttpConfigRef","newHttpConfig","ref","equals","current","expiryTime"],"mappings":"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","sourcesContent":["import { useEffect, useRef } from 'react';\nimport * as R from 'ramda';\nimport { GatekeeperRecordState, GatewayStatus } from '../types';\nimport logger from '../logger';\nimport useWalletHooks from './useWalletHooks';\nexport const reducer = (state, action) => {\n    switch (action.type) {\n        case 'getGatekeeperRecord':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.CHECKING, gatekeeperRecordState: undefined });\n        case 'getGatekeeperRecord_failure':\n            return Object.assign(Object.assign({}, state), { gatekeeperRecordState: action.gatekeeperRecord.state });\n        case 'getGatekeeperRecord_success':\n            return Object.assign(Object.assign({}, state), { gatekeeperRecordState: action.gatekeeperRecord.state, civicPass: Object.assign(Object.assign({}, state.civicPass), { requestPayload: action.gatekeeperRecord.payload }) });\n        case 'getGatekeeperRecord_location_not_supported':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.LOCATION_NOT_SUPPORTED, gatekeeperRecordState: action.gatekeeperRecord.state, civicPass: Object.assign(Object.assign({}, state.civicPass), { requestPayload: action.gatekeeperRecord.payload }) });\n        case 'getGatekeeperRecord_issued_location_not_supported':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.LOCATION_NOT_SUPPORTED, gatekeeperRecordState: action.gatekeeperRecord.state, civicPass: Object.assign(Object.assign({}, state.civicPass), { requestPayload: action.gatekeeperRecord.payload }) });\n        case 'getGatekeeperRecord_not_found':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.NOT_REQUESTED, gatekeeperRecordState: action.gatekeeperRecord.state });\n        default:\n            return state;\n    }\n};\nconst useGetGatekeeperRecord = ({ wallet, gatekeeperClient, httpConfig, }, state, dispatch) => {\n    const { expectWalletConnected } = useWalletHooks(wallet, state, dispatch);\n    const logDebug = (message, obj = null) => logger.debug(`[useGetGatekeeperRecord] ${message}`, obj);\n    const { gatewayToken, gatekeeperNetworkAddress } = state;\n    const dispatchFetch = () => ({\n        type: 'getGatekeeperRecord',\n    });\n    const dispatchFailure = () => ({\n        type: 'getGatekeeperRecord_failure',\n        gatekeeperRecord: { state: GatekeeperRecordState.SERVER_FAILURE, payload: undefined },\n    });\n    const dispatchSuccess = (record) => ({\n        type: 'getGatekeeperRecord_success',\n        gatekeeperRecord: record,\n    });\n    const dispatchLocationNotSupported = (record) => ({\n        type: 'getGatekeeperRecord_location_not_supported',\n        gatekeeperRecord: record,\n    });\n    const dispatchIssuedLocationNotSupported = (record) => ({\n        type: 'getGatekeeperRecord_issued_location_not_supported',\n        gatekeeperRecord: record,\n    });\n    const dispatchRecordNotFound = (record) => ({\n        type: 'getGatekeeperRecord_not_found',\n        gatekeeperRecord: record,\n    });\n    const getAction = (gatekeeperRecordState) => {\n        const actions = {\n            [GatekeeperRecordState.REQUESTED]: () => dispatchSuccess(gatekeeperRecordState),\n            [GatekeeperRecordState.ISSUED]: () => dispatchSuccess(gatekeeperRecordState),\n            [GatekeeperRecordState.ISSUED_EXPIRED]: () => dispatchSuccess(gatekeeperRecordState),\n            [GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING]: () => dispatchSuccess(gatekeeperRecordState),\n            [GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED]: () => dispatchIssuedLocationNotSupported(gatekeeperRecordState),\n            [GatekeeperRecordState.LOCATION_NOT_SUPPORTED]: () => dispatchLocationNotSupported(gatekeeperRecordState),\n            [GatekeeperRecordState.NOT_REQUESTED]: () => dispatchRecordNotFound(gatekeeperRecordState),\n        };\n        return actions[gatekeeperRecordState.state];\n    };\n    /**\n     * Check to see if there is getGatekeeperRecord and dispatch actions based on the state of the record.\n     * If the service call fails dispatch a failure.\n     */\n    const dispatchGatekeeperRecord = async () => {\n        const walletAddress = expectWalletConnected();\n        logDebug('Fetching Gatekeeper record');\n        dispatch(dispatchFetch());\n        try {\n            const record = await gatekeeperClient().getGatekeeperRecordWithPayload(walletAddress.publicKey);\n            logDebug('Gatekeeper record response state: ', GatekeeperRecordState[record.state]);\n            const action = getAction(record);\n            if (!action) {\n                logger.error('Cannot dispatch action for invalid Gatekeeper Record State.', { record });\n                return;\n            }\n            dispatch(action());\n        }\n        catch (error) {\n            logger.error('Failed to fetch Gatekeeper record', error);\n            dispatch(dispatchFailure());\n            throw error;\n        }\n    };\n    const useHttpConfigRef = (newHttpConfig) => {\n        const ref = useRef();\n        // We have to perform a deep equality check, otherwise useEffect will run every time the httpConfig object reference changes.\n        if (!R.equals(newHttpConfig, ref.current)) {\n            ref.current = newHttpConfig;\n        }\n        return ref.current;\n    };\n    useEffect(() => {\n        if (!wallet || !wallet.publicKey)\n            return;\n        dispatchGatekeeperRecord();\n    }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.state, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress, useHttpConfigRef(httpConfig)]);\n    return { dispatchGatekeeperRecord };\n};\nexport default useGetGatekeeperRecord;\n"]},"metadata":{},"sourceType":"module"}