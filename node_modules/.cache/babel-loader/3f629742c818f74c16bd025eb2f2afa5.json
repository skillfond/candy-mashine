{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Test Mint\\\\metaplex\\\\js\\\\packages\\\\candy-machine-ui\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gatekeeperExists = exports.getGatewayToken = exports.removeAccountChangeListener = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokens = exports.dataToGatewayToken = exports.getGatewayTokenKeyForOwner = exports.getGatekeeperAccountKey = exports.proxyConnectionWithRetry = exports.runFunctionWithRetry = exports.defaultRetryConfig = void 0;\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nvar constants_1 = require(\"./constants\");\n\nvar types_1 = require(\"../types\");\n\nvar GatewayTokenData_1 = require(\"./GatewayTokenData\");\n\nvar async_retry_1 = __importDefault(require(\"async-retry\"));\n\nvar R = __importStar(require(\"ramda\"));\n\nexports.defaultRetryConfig = {\n  retryCount: constants_1.DEFAULT_SOLANA_RETRIES,\n  exponentialFactor: 2,\n  timeouts: {\n    processed: constants_1.SOLANA_TIMEOUT_PROCESSED,\n    confirmed: constants_1.SOLANA_TIMEOUT_CONFIRMED,\n    finalized: constants_1.SOLANA_TIMEOUT_FINALIZED\n  }\n};\n\nvar runFunctionWithRetry = function runFunctionWithRetry(methodName, // for logging purposes so we know which call this was\nfn, commitment, customRetryConfig) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var retryConfig, timeout, retryCount, expFactor, currentAttempt;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            retryConfig = Object.assign(Object.assign({}, exports.defaultRetryConfig), customRetryConfig);\n            timeout = R.path([\"timeouts\", commitment], retryConfig) || retryConfig.timeouts.confirmed; //Â If we have any bugs before this point, this is the final safeguard against undefined retry config values.\n            // TODO IDCOM-1558 Improve the type safety of config to avoid the need for checks such as this.\n\n            retryCount = retryConfig.retryCount;\n            expFactor = retryConfig.exponentialFactor;\n\n            if (!retryCount) {\n              console.error(\"retryCount not set in Solana connection proxy. Defaulting to \".concat(constants_1.DEFAULT_SOLANA_RETRIES));\n              retryCount = constants_1.DEFAULT_SOLANA_RETRIES;\n            }\n\n            if (!expFactor) {\n              console.error(\"exponentialFactor not set in Solana connection proxy. Defaulting to 2\");\n              retryCount = 2;\n            }\n\n            if (!timeout) {\n              console.error(\"timeout not set in Solana connection proxy. Defaulting to \".concat(constants_1.SOLANA_TIMEOUT_CONFIRMED));\n              timeout = constants_1.SOLANA_TIMEOUT_CONFIRMED;\n            }\n\n            currentAttempt = 0;\n            _context2.prev = 8;\n            _context2.next = 11;\n            return (0, async_retry_1.default)(function () {\n              return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                var timeoutPromise, blockchainPromise;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        currentAttempt++;\n                        console.log(\"Trying Solana connection method '\".concat(methodName, \"' (attempt \").concat(currentAttempt, \" of \").concat(retryConfig.retryCount + 1, \")\"), {\n                          timeout: timeout\n                        });\n                        timeoutPromise = new Promise(function (_resolve, reject) {\n                          return setTimeout(function () {\n                            return reject(new Error(\"timeout\"));\n                          }, timeout);\n                        });\n                        blockchainPromise = fn();\n                        return _context.abrupt(\"return\", Promise.race([blockchainPromise, timeoutPromise]));\n\n                      case 5:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n            }, {\n              retries: retryCount,\n              factor: expFactor\n            });\n\n          case 11:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 14:\n            _context2.prev = 14;\n            _context2.t0 = _context2[\"catch\"](8);\n            console.error(\"Retries exhausted in Solana connection method '\".concat(methodName, \"' .\"), {\n              error: _context2.t0\n            });\n            throw _context2.t0;\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[8, 14]]);\n  }));\n};\n\nexports.runFunctionWithRetry = runFunctionWithRetry;\n\nvar proxyConnectionWithRetry = function proxyConnectionWithRetry(originalConnection) {\n  var customRetryConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.defaultRetryConfig;\n  var proxyHandler = {\n    get: function get(target, propKey, receiver) {\n      var _this = this;\n\n      switch (propKey) {\n        case \"sendTransaction\":\n          return function (transaction, signers, options) {\n            var fn = function fn() {\n              return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        return _context3.abrupt(\"return\", target.sendTransaction(transaction, signers, options));\n\n                      case 1:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n            };\n\n            return (0, exports.runFunctionWithRetry)(\"sendTransaction\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n          };\n\n        case \"confirmTransaction\":\n          return function (signature, commitment) {\n            var fn = function fn() {\n              return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        return _context4.abrupt(\"return\", target.confirmTransaction(signature, commitment));\n\n                      case 1:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4);\n              }));\n            };\n\n            return (0, exports.runFunctionWithRetry)(\"confirmTransaction\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n          };\n\n        case \"getProgramAccounts\":\n          return function (programId, configOrCommitment) {\n            var fn = function fn() {\n              return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                        return _context5.abrupt(\"return\", target.getProgramAccounts(programId, configOrCommitment));\n\n                      case 1:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              }));\n            };\n\n            return (0, exports.runFunctionWithRetry)(\"getProgramAccounts\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n          };\n\n        case \"getAccountInfo\":\n          return function (publicKey, commitment) {\n            var fn = function fn() {\n              return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                  while (1) {\n                    switch (_context6.prev = _context6.next) {\n                      case 0:\n                        return _context6.abrupt(\"return\", target.getAccountInfo(publicKey, commitment));\n\n                      case 1:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }\n                }, _callee6);\n              }));\n            };\n\n            return (0, exports.runFunctionWithRetry)(\"getAccountInfo\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n          };\n\n        default:\n          // Return the original property unchanged:\n          return Reflect.get(target, propKey, receiver);\n      }\n    },\n    apply: function apply(target, thisArg, argumentsList) {\n      var _this2 = this;\n\n      var fn = function fn() {\n        return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n          return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  return _context7.abrupt(\"return\", target.apply(thisArg, argumentsList));\n\n                case 1:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7);\n        }));\n      };\n\n      return (0, exports.runFunctionWithRetry)(\"apply\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n    }\n  };\n  return new Proxy(originalConnection, proxyHandler);\n};\n\nexports.proxyConnectionWithRetry = proxyConnectionWithRetry;\n/**\n * Derive the address of the gatekeeper PDA for this gatekeeper\n * @param authority The gatekeeper\n * @param network The network\n */\n\nvar getGatekeeperAccountKey = function getGatekeeperAccountKey(authority, network) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n    var publicKeyNonce;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return web3_js_1.PublicKey.findProgramAddress([authority.toBuffer(), network.toBuffer(), Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, \"utf8\")], constants_1.PROGRAM_ID);\n\n          case 2:\n            publicKeyNonce = _context8.sent;\n            return _context8.abrupt(\"return\", publicKeyNonce[0]);\n\n          case 4:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n};\n\nexports.getGatekeeperAccountKey = getGatekeeperAccountKey;\n/**\n * Derive the address of the gateway token PDA for this owner address and optional seed.\n * @param owner The owner of the gateway token\n * @param gatekeeperNetwork The network of the gateway token\n * @param seed An 8-byte seed array, used to add multiple tokens to the same owner. Must be unique to each token, if present\n */\n\nvar getGatewayTokenKeyForOwner = function getGatewayTokenKeyForOwner(owner, gatekeeperNetwork, seed) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n    var additionalSeed, seeds, publicKeyNonce;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            additionalSeed = seed ? Buffer.from(seed) : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n\n            if (!(additionalSeed.length != 8)) {\n              _context9.next = 3;\n              break;\n            }\n\n            throw new Error(\"Additional Seed has length \" + additionalSeed.length + \" instead of 8 when calling getGatewayTokenKeyForOwner.\");\n\n          case 3:\n            seeds = [owner.toBuffer(), Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, \"utf8\"), additionalSeed, gatekeeperNetwork.toBuffer()];\n            _context9.next = 6;\n            return web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.PROGRAM_ID);\n\n          case 6:\n            publicKeyNonce = _context9.sent;\n            return _context9.abrupt(\"return\", publicKeyNonce[0]);\n\n          case 8:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n};\n\nexports.getGatewayTokenKeyForOwner = getGatewayTokenKeyForOwner; // Based on solana/integration-lib/src/state.rs\n// If the optional the parent-gateway-token field is populated, this value will be\n// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put\n// all optional values at the end of the struct to simplify account parsing a little\n\nvar GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2; // As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this\n\nvar GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;\n\nfunction fromGatewayTokenState(state) {\n  if (!!state.active) return types_1.State.ACTIVE;\n  if (!!state.revoked) return types_1.State.REVOKED;\n  if (!!state.frozen) return types_1.State.FROZEN;\n  throw new Error(\"Unrecognised state \" + JSON.stringify(state));\n}\n\nvar dataToGatewayToken = function dataToGatewayToken(data, publicKey) {\n  var _a;\n\n  return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());\n};\n\nexports.dataToGatewayToken = dataToGatewayToken;\n/**\n * Find all gateway tokens for a user on a gatekeeper network, optionally filtering out revoked tokens\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens\n * @returns {Promise<GatewayToken[]>} All tokens for the owner\n */\n\nvar findGatewayTokens = function findGatewayTokens(connection, owner, gatekeeperNetwork) {\n  var includeRevoked = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n    var ownerFilter, gatekeeperNetworkFilter, filters, accountsResponse, toGatewayToken;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            ownerFilter = {\n              memcmp: {\n                offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n                bytes: owner.toBase58()\n              }\n            };\n            gatekeeperNetworkFilter = {\n              memcmp: {\n                offset: GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,\n                bytes: gatekeeperNetwork === null || gatekeeperNetwork === void 0 ? void 0 : gatekeeperNetwork.toBase58()\n              }\n            };\n            filters = [ownerFilter, gatekeeperNetworkFilter];\n            _context10.next = 5;\n            return connection.getProgramAccounts(constants_1.PROGRAM_ID, {\n              filters: filters\n            });\n\n          case 5:\n            accountsResponse = _context10.sent;\n\n            if (accountsResponse) {\n              _context10.next = 8;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", []);\n\n          case 8:\n            toGatewayToken = function toGatewayToken(_ref) {\n              var pubkey = _ref.pubkey,\n                  account = _ref.account;\n              return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);\n            };\n\n            return _context10.abrupt(\"return\", accountsResponse.map(toGatewayToken).filter(function (gatewayToken) {\n              return gatewayToken.state !== types_1.State.REVOKED || includeRevoked;\n            }));\n\n          case 10:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n};\n\nexports.findGatewayTokens = findGatewayTokens;\n/**\n * Find any unrevoked token for a user on a gatekeeper network\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner\n */\n\nvar findGatewayToken = function findGatewayToken(connection, owner, gatekeeperNetwork) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n    var tokens, validTokens, nonRevokedTokens;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return (0, exports.findGatewayTokens)(connection, owner, gatekeeperNetwork, false);\n\n          case 2:\n            tokens = _context11.sent;\n\n            if (!(tokens.length === 0)) {\n              _context11.next = 5;\n              break;\n            }\n\n            return _context11.abrupt(\"return\", null);\n\n          case 5:\n            // if any are valid, return the first one\n            validTokens = tokens.filter(function (token) {\n              return token.isValid();\n            });\n\n            if (!(validTokens.length > 0)) {\n              _context11.next = 8;\n              break;\n            }\n\n            return _context11.abrupt(\"return\", validTokens[0]);\n\n          case 8:\n            // if none is valid, return the first non-revoked one\n            nonRevokedTokens = tokens.filter(function (token) {\n              return token.state !== types_1.State.REVOKED;\n            });\n            return _context11.abrupt(\"return\", nonRevokedTokens.length === 0 ? null : nonRevokedTokens[0]);\n\n          case 10:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n};\n\nexports.findGatewayToken = findGatewayToken;\n/**\n * Register a callback to be called whenever a gateway token changes state\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n * @param callback The callback to register\n * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'\n * @return The subscription id\n */\n\nvar onGatewayTokenChange = function onGatewayTokenChange(connection, gatewayTokenAddress, callback) {\n  var commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_1.SOLANA_COMMITMENT;\n\n  var accountCallback = function accountCallback(accountInfo) {\n    var gatewayToken = (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);\n    callback(gatewayToken);\n  };\n\n  return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);\n};\n\nexports.onGatewayTokenChange = onGatewayTokenChange;\n/**\n * Stops listening to gateway state changes\n * @param connection A solana connection object\n * @param id The subscription id to deregister\n */\n\nvar removeAccountChangeListener = function removeAccountChangeListener(connection, id) {\n  return connection.removeAccountChangeListener(id);\n};\n\nexports.removeAccountChangeListener = removeAccountChangeListener;\n/**\n * Lookup the gateway token at a given address\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n */\n\nvar getGatewayToken = function getGatewayToken(connection, gatewayTokenAddress) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n    var account;\n    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            _context12.next = 2;\n            return connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n\n          case 2:\n            account = _context12.sent;\n\n            if (account) {\n              _context12.next = 5;\n              break;\n            }\n\n            return _context12.abrupt(\"return\", null);\n\n          case 5:\n            return _context12.abrupt(\"return\", (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress));\n\n          case 6:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n};\n\nexports.getGatewayToken = getGatewayToken;\n/**\n * Returns whether or not a gatekeeper exists from a network and authority\n * @param connection A solana connection\n * @param gatekeeperAuthority The authority of the gatekeeper\n * @param gatekeeperNetwork The network of the gatekeeper\n */\n\nvar gatekeeperExists = function gatekeeperExists(connection, gatekeeperAuthority, gatekeeperNetwork) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n    var gatekeeperAccount, account;\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return (0, exports.getGatekeeperAccountKey)(gatekeeperAuthority, gatekeeperNetwork);\n\n          case 2:\n            gatekeeperAccount = _context13.sent;\n            _context13.next = 5;\n            return connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);\n\n          case 5:\n            account = _context13.sent;\n            return _context13.abrupt(\"return\", account != null && account.owner == constants_1.PROGRAM_ID);\n\n          case 7:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n};\n\nexports.gatekeeperExists = gatekeeperExists;","map":{"version":3,"sources":["../../src/lib/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gatekeeperExists = exports.getGatewayToken = exports.removeAccountChangeListener = exports.onGatewayTokenChange = exports.findGatewayToken = exports.findGatewayTokens = exports.dataToGatewayToken = exports.getGatewayTokenKeyForOwner = exports.getGatekeeperAccountKey = exports.proxyConnectionWithRetry = exports.runFunctionWithRetry = exports.defaultRetryConfig = void 0;\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst constants_1 = require(\"./constants\");\nconst types_1 = require(\"../types\");\nconst GatewayTokenData_1 = require(\"./GatewayTokenData\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst R = __importStar(require(\"ramda\"));\nexports.defaultRetryConfig = {\n    retryCount: constants_1.DEFAULT_SOLANA_RETRIES,\n    exponentialFactor: 2,\n    timeouts: {\n        processed: constants_1.SOLANA_TIMEOUT_PROCESSED,\n        confirmed: constants_1.SOLANA_TIMEOUT_CONFIRMED,\n        finalized: constants_1.SOLANA_TIMEOUT_FINALIZED,\n    },\n};\nconst runFunctionWithRetry = (methodName, // for logging purposes so we know which call this was\nfn, commitment, customRetryConfig) => __awaiter(void 0, void 0, void 0, function* () {\n    const retryConfig = Object.assign(Object.assign({}, exports.defaultRetryConfig), customRetryConfig);\n    let timeout = R.path([\"timeouts\", commitment], retryConfig) ||\n        retryConfig.timeouts.confirmed;\n    //Â If we have any bugs before this point, this is the final safeguard against undefined retry config values.\n    // TODO IDCOM-1558 Improve the type safety of config to avoid the need for checks such as this.\n    let retryCount = retryConfig.retryCount;\n    let expFactor = retryConfig.exponentialFactor;\n    if (!retryCount) {\n        console.error(`retryCount not set in Solana connection proxy. Defaulting to ${constants_1.DEFAULT_SOLANA_RETRIES}`);\n        retryCount = constants_1.DEFAULT_SOLANA_RETRIES;\n    }\n    if (!expFactor) {\n        console.error(\"exponentialFactor not set in Solana connection proxy. Defaulting to 2\");\n        retryCount = 2;\n    }\n    if (!timeout) {\n        console.error(`timeout not set in Solana connection proxy. Defaulting to ${constants_1.SOLANA_TIMEOUT_CONFIRMED}`);\n        timeout = constants_1.SOLANA_TIMEOUT_CONFIRMED;\n    }\n    let currentAttempt = 0;\n    try {\n        return yield (0, async_retry_1.default)(() => __awaiter(void 0, void 0, void 0, function* () {\n            currentAttempt++;\n            console.log(`Trying Solana connection method '${methodName}' (attempt ${currentAttempt} of ${retryConfig.retryCount + 1})`, { timeout });\n            const timeoutPromise = new Promise((_resolve, reject) => setTimeout(() => reject(new Error(\"timeout\")), timeout));\n            const blockchainPromise = fn();\n            return Promise.race([blockchainPromise, timeoutPromise]);\n        }), {\n            retries: retryCount,\n            factor: expFactor,\n        });\n    }\n    catch (err) {\n        console.error(`Retries exhausted in Solana connection method '${methodName}' .`, { error: err });\n        throw err;\n    }\n});\nexports.runFunctionWithRetry = runFunctionWithRetry;\nconst proxyConnectionWithRetry = (originalConnection, customRetryConfig = exports.defaultRetryConfig) => {\n    const proxyHandler = {\n        get(target, propKey, receiver) {\n            switch (propKey) {\n                case \"sendTransaction\":\n                    return (transaction, signers, options) => {\n                        const fn = () => __awaiter(this, void 0, void 0, function* () { return target.sendTransaction(transaction, signers, options); });\n                        return (0, exports.runFunctionWithRetry)(\"sendTransaction\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n                    };\n                case \"confirmTransaction\":\n                    return (signature, commitment) => {\n                        const fn = () => __awaiter(this, void 0, void 0, function* () { return target.confirmTransaction(signature, commitment); });\n                        return (0, exports.runFunctionWithRetry)(\"confirmTransaction\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n                    };\n                case \"getProgramAccounts\":\n                    return (programId, configOrCommitment) => {\n                        const fn = () => __awaiter(this, void 0, void 0, function* () { return target.getProgramAccounts(programId, configOrCommitment); });\n                        return (0, exports.runFunctionWithRetry)(\"getProgramAccounts\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n                    };\n                case \"getAccountInfo\":\n                    return (publicKey, commitment) => {\n                        const fn = () => __awaiter(this, void 0, void 0, function* () { return target.getAccountInfo(publicKey, commitment); });\n                        return (0, exports.runFunctionWithRetry)(\"getAccountInfo\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n                    };\n                default:\n                    // Return the original property unchanged:\n                    return Reflect.get(target, propKey, receiver);\n            }\n        },\n        apply(target, thisArg, argumentsList) {\n            const fn = () => __awaiter(this, void 0, void 0, function* () { return target.apply(thisArg, argumentsList); });\n            return (0, exports.runFunctionWithRetry)(\"apply\", fn, constants_1.SOLANA_COMMITMENT, customRetryConfig);\n        },\n    };\n    return new Proxy(originalConnection, proxyHandler);\n};\nexports.proxyConnectionWithRetry = proxyConnectionWithRetry;\n/**\n * Derive the address of the gatekeeper PDA for this gatekeeper\n * @param authority The gatekeeper\n * @param network The network\n */\nconst getGatekeeperAccountKey = (authority, network) => __awaiter(void 0, void 0, void 0, function* () {\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress([\n        authority.toBuffer(),\n        network.toBuffer(),\n        Buffer.from(constants_1.GATEKEEPER_NONCE_SEED_STRING, \"utf8\"),\n    ], constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getGatekeeperAccountKey = getGatekeeperAccountKey;\n/**\n * Derive the address of the gateway token PDA for this owner address and optional seed.\n * @param owner The owner of the gateway token\n * @param gatekeeperNetwork The network of the gateway token\n * @param seed An 8-byte seed array, used to add multiple tokens to the same owner. Must be unique to each token, if present\n */\nconst getGatewayTokenKeyForOwner = (owner, gatekeeperNetwork, seed) => __awaiter(void 0, void 0, void 0, function* () {\n    const additionalSeed = seed\n        ? Buffer.from(seed)\n        : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]);\n    if (additionalSeed.length != 8) {\n        throw new Error(\"Additional Seed has length \" +\n            additionalSeed.length +\n            \" instead of 8 when calling getGatewayTokenKeyForOwner.\");\n    }\n    const seeds = [\n        owner.toBuffer(),\n        Buffer.from(constants_1.GATEWAY_TOKEN_ADDRESS_SEED, \"utf8\"),\n        additionalSeed,\n        gatekeeperNetwork.toBuffer(),\n    ];\n    const publicKeyNonce = yield web3_js_1.PublicKey.findProgramAddress(seeds, constants_1.PROGRAM_ID);\n    return publicKeyNonce[0];\n});\nexports.getGatewayTokenKeyForOwner = getGatewayTokenKeyForOwner;\n// Based on solana/integration-lib/src/state.rs\n// If the optional the parent-gateway-token field is populated, this value will be\n// 34 (2 + 32) instead. TODO IDCOM-320 restructure the gateway token accounts to put\n// all optional values at the end of the struct to simplify account parsing a little\nconst GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET = 2;\n// As above, if optional fields are present, this will differ. TODO IDCOM-320 fixes this\nconst GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET = 35;\nfunction fromGatewayTokenState(state) {\n    if (!!state.active)\n        return types_1.State.ACTIVE;\n    if (!!state.revoked)\n        return types_1.State.REVOKED;\n    if (!!state.frozen)\n        return types_1.State.FROZEN;\n    throw new Error(\"Unrecognised state \" + JSON.stringify(state));\n}\nconst dataToGatewayToken = (data, publicKey) => {\n    var _a;\n    return new types_1.GatewayToken(data.issuingGatekeeper.toPublicKey(), data.gatekeeperNetwork.toPublicKey(), data.owner.toPublicKey(), fromGatewayTokenState(data.state), publicKey, constants_1.PROGRAM_ID, (_a = data.expiry) === null || _a === void 0 ? void 0 : _a.toNumber());\n};\nexports.dataToGatewayToken = dataToGatewayToken;\n/**\n * Find all gateway tokens for a user on a gatekeeper network, optionally filtering out revoked tokens\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @param {boolean=false} includeRevoked If false (default), filter out revoked tokens\n * @returns {Promise<GatewayToken[]>} All tokens for the owner\n */\nconst findGatewayTokens = (connection, owner, gatekeeperNetwork, includeRevoked = false) => __awaiter(void 0, void 0, void 0, function* () {\n    const ownerFilter = {\n        memcmp: {\n            offset: GATEWAY_TOKEN_ACCOUNT_OWNER_FIELD_OFFSET,\n            bytes: owner.toBase58(),\n        },\n    };\n    const gatekeeperNetworkFilter = {\n        memcmp: {\n            offset: GATEWAY_TOKEN_ACCOUNT_GATEKEEPER_NETWORK_FIELD_OFFSET,\n            bytes: gatekeeperNetwork === null || gatekeeperNetwork === void 0 ? void 0 : gatekeeperNetwork.toBase58(),\n        },\n    };\n    const filters = [ownerFilter, gatekeeperNetworkFilter];\n    const accountsResponse = yield connection.getProgramAccounts(constants_1.PROGRAM_ID, {\n        filters,\n    });\n    if (!accountsResponse)\n        return [];\n    const toGatewayToken = ({ pubkey, account, }) => (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), pubkey);\n    return accountsResponse\n        .map(toGatewayToken)\n        .filter((gatewayToken) => gatewayToken.state !== types_1.State.REVOKED || includeRevoked);\n});\nexports.findGatewayTokens = findGatewayTokens;\n/**\n * Find any unrevoked token for a user on a gatekeeper network\n * @param connection A solana connection object\n * @param owner The token owner\n * @param gatekeeperNetwork The network to find a token for\n * @returns Promise<GatewayToken | null> An unrevoked token, if one exists for the owner\n */\nconst findGatewayToken = (connection, owner, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n    const tokens = yield (0, exports.findGatewayTokens)(connection, owner, gatekeeperNetwork, false);\n    if (tokens.length === 0)\n        return null;\n    // if any are valid, return the first one\n    const validTokens = tokens.filter((token) => token.isValid());\n    if (validTokens.length > 0)\n        return validTokens[0];\n    // if none is valid, return the first non-revoked one\n    const nonRevokedTokens = tokens.filter((token) => token.state !== types_1.State.REVOKED);\n    return nonRevokedTokens.length === 0 ? null : nonRevokedTokens[0];\n});\nexports.findGatewayToken = findGatewayToken;\n/**\n * Register a callback to be called whenever a gateway token changes state\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n * @param callback The callback to register\n * @param commitment The solana commitment level at which to register gateway token changes. Defaults to 'confirmed'\n * @return The subscription id\n */\nconst onGatewayTokenChange = (connection, gatewayTokenAddress, callback, commitment = constants_1.SOLANA_COMMITMENT) => {\n    const accountCallback = (accountInfo) => {\n        const gatewayToken = (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(accountInfo.data), gatewayTokenAddress);\n        callback(gatewayToken);\n    };\n    return connection.onAccountChange(gatewayTokenAddress, accountCallback, commitment);\n};\nexports.onGatewayTokenChange = onGatewayTokenChange;\n/**\n * Stops listening to gateway state changes\n * @param connection A solana connection object\n * @param id The subscription id to deregister\n */\nconst removeAccountChangeListener = (connection, id) => connection.removeAccountChangeListener(id);\nexports.removeAccountChangeListener = removeAccountChangeListener;\n/**\n * Lookup the gateway token at a given address\n * @param connection A solana connection object\n * @param gatewayTokenAddress The address of the gateway token\n */\nconst getGatewayToken = (connection, gatewayTokenAddress) => __awaiter(void 0, void 0, void 0, function* () {\n    const account = yield connection.getAccountInfo(gatewayTokenAddress, constants_1.SOLANA_COMMITMENT);\n    if (!account)\n        return null;\n    return (0, exports.dataToGatewayToken)(GatewayTokenData_1.GatewayTokenData.fromAccount(account.data), gatewayTokenAddress);\n});\nexports.getGatewayToken = getGatewayToken;\n/**\n * Returns whether or not a gatekeeper exists from a network and authority\n * @param connection A solana connection\n * @param gatekeeperAuthority The authority of the gatekeeper\n * @param gatekeeperNetwork The network of the gatekeeper\n */\nconst gatekeeperExists = (connection, gatekeeperAuthority, gatekeeperNetwork) => __awaiter(void 0, void 0, void 0, function* () {\n    const gatekeeperAccount = yield (0, exports.getGatekeeperAccountKey)(gatekeeperAuthority, gatekeeperNetwork);\n    const account = yield connection.getAccountInfo(gatekeeperAccount, constants_1.SOLANA_COMMITMENT);\n    return account != null && account.owner == constants_1.PROGRAM_ID;\n});\nexports.gatekeeperExists = gatekeeperExists;\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"script"}