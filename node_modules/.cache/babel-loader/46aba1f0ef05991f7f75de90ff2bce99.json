{"ast":null,"code":"import fetchBuilder from 'fetch-retry-ts';\nimport { GatekeeperRecordState } from '../types';\nimport logger from '../logger';\nimport { getDefaultApiNumRetries } from '../config';\n\nconst testRetryMultipler = () => parseFloat(process.env.TEST_RETRY_MULTIPLIER || '') || 1;\n\nexport default class GatekeeperClient {\n  constructor(gatekeeperClientConfig) {\n    this.baseUrl = gatekeeperClientConfig.baseUrl;\n    this.stage = gatekeeperClientConfig.stage;\n    this.queryParams = gatekeeperClientConfig.queryParams;\n    this.fetchImplementation = gatekeeperClientConfig.fetchImplementation || fetch; // By default retry on every 5xx or other Error (e.g. network failure):\n\n    this.defaultRetryParams = {\n      retries: gatekeeperClientConfig.numRetries || getDefaultApiNumRetries(this.stage),\n      retryOn: (attempt, retries, error, response) => attempt < retries && (!!error || !response || response.status >= 500),\n      retryDelay: attempt => 2 ** attempt * 1000 * testRetryMultipler()\n    };\n    this.fetchWithRetry = fetchBuilder(this.fetchImplementation, this.defaultRetryParams);\n  }\n\n  addQueryParams(url) {\n    if (!this.queryParams) return;\n    Object.entries(this.queryParams).forEach(_ref => {\n      let [key, value] = _ref;\n      url.searchParams.append(key, value);\n    });\n  }\n\n  urlForWallet(walletAddress) {\n    const url = new URL(`${this.baseUrl}/${walletAddress}`);\n    this.addQueryParams(url);\n    return url.toString();\n  }\n\n  async getGatekeeperRecordWithPayload(walletAddress) {\n    return this.fetchWithRetry(this.urlForWallet(walletAddress), {\n      method: 'GET'\n    }).then(async response => ({\n      state: GatekeeperRecordState[GatekeeperRecordState[response.status]],\n      payload: await response.json()\n    }));\n  }\n  /**\n   * Polls the gatekeeper status until 2xx or 4xx is received except 404 for which it retries.\n   */\n\n\n  async pollGatekeeperStatus(walletAddress) {\n    const isTokenCreated = code => code === 200;\n\n    const isFailure = code => code !== 404 && code >= 400 && code < 500;\n\n    const pollRetryParams = Object.assign(Object.assign({}, this.defaultRetryParams), {\n      retries: 5 * 30,\n      retryOn: (attempt, retries, error, response) => attempt < retries && (!!error || !response || !isTokenCreated(response.status) && !isFailure(response.status)),\n      retryDelay: 2000 * testRetryMultipler()\n    });\n    const pollingFetch = fetchBuilder(this.fetchImplementation, pollRetryParams);\n    const pollRes = pollingFetch(this.urlForWallet(walletAddress), {\n      method: 'HEAD'\n    });\n    return pollRes.then(_ref2 => {\n      let {\n        status\n      } = _ref2;\n      return status;\n    });\n  }\n\n  async requestGatewayTokenFromGatekeeper(_ref3) {\n    let {\n      wallet,\n      payload,\n      proof\n    } = _ref3;\n    // produce a signature that proves ownership of a wallet\n    logger.debug('requestGatewayTokenFromGatekeeper request', Object.assign(Object.assign({}, payload), {\n      proof\n    })); // We only pass the wallet public key as part of the request if\n    // it was not passed as part of the presentation.\n\n    const body = Object.assign(Object.assign({}, payload), {\n      proof,\n      address: wallet.publicKey\n    });\n    const gatewayTokenCreationRequest = Object.assign(Object.assign({}, body), {\n      proof\n    });\n    logger.debug('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', gatewayTokenCreationRequest);\n    const url = new URL(this.baseUrl);\n    this.addQueryParams(url);\n    return this.fetchWithRetry(url.toString(), {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(gatewayTokenCreationRequest)\n    }).then(resp => resp);\n  }\n  /**\n   * Tries to refresh a token.\n   * If it fails with a 5xx, handleFetchError will retry a number of times.\n   */\n\n\n  async refreshToken(gatewayTokenKey, walletPublicKey, proof, payload) {\n    logger.debug('refreshToken...', {\n      gatewayTokenKey,\n      payload\n    });\n    logger.debug('Attempting to refresh the Gateway token');\n    return this.fetchWithRetry(this.urlForWallet(walletPublicKey), {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(Object.assign({\n        proof,\n        request: 'refresh'\n      }, payload))\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Test Mint/metaplex/JS/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/utils/gatekeeperClient.js"],"names":["fetchBuilder","GatekeeperRecordState","logger","getDefaultApiNumRetries","testRetryMultipler","parseFloat","process","env","TEST_RETRY_MULTIPLIER","GatekeeperClient","constructor","gatekeeperClientConfig","baseUrl","stage","queryParams","fetchImplementation","fetch","defaultRetryParams","retries","numRetries","retryOn","attempt","error","response","status","retryDelay","fetchWithRetry","addQueryParams","url","Object","entries","forEach","key","value","searchParams","append","urlForWallet","walletAddress","URL","toString","getGatekeeperRecordWithPayload","method","then","state","payload","json","pollGatekeeperStatus","isTokenCreated","code","isFailure","pollRetryParams","assign","pollingFetch","pollRes","requestGatewayTokenFromGatekeeper","wallet","proof","debug","body","address","publicKey","gatewayTokenCreationRequest","headers","JSON","stringify","resp","refreshToken","gatewayTokenKey","walletPublicKey","request"],"mappings":"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","sourcesContent":["import fetchBuilder from 'fetch-retry-ts';\nimport { GatekeeperRecordState } from '../types';\nimport logger from '../logger';\nimport { getDefaultApiNumRetries } from '../config';\nconst testRetryMultipler = () => parseFloat(process.env.TEST_RETRY_MULTIPLIER || '') || 1;\nexport default class GatekeeperClient {\n    constructor(gatekeeperClientConfig) {\n        this.baseUrl = gatekeeperClientConfig.baseUrl;\n        this.stage = gatekeeperClientConfig.stage;\n        this.queryParams = gatekeeperClientConfig.queryParams;\n        this.fetchImplementation = gatekeeperClientConfig.fetchImplementation || fetch;\n        // By default retry on every 5xx or other Error (e.g. network failure):\n        this.defaultRetryParams = {\n            retries: gatekeeperClientConfig.numRetries || getDefaultApiNumRetries(this.stage),\n            retryOn: (attempt, retries, error, response) => attempt < retries && (!!error || !response || response.status >= 500),\n            retryDelay: (attempt) => 2 ** attempt * 1000 * testRetryMultipler(),\n        };\n        this.fetchWithRetry = fetchBuilder(this.fetchImplementation, this.defaultRetryParams);\n    }\n    addQueryParams(url) {\n        if (!this.queryParams)\n            return;\n        Object.entries(this.queryParams).forEach(([key, value]) => {\n            url.searchParams.append(key, value);\n        });\n    }\n    urlForWallet(walletAddress) {\n        const url = new URL(`${this.baseUrl}/${walletAddress}`);\n        this.addQueryParams(url);\n        return url.toString();\n    }\n    async getGatekeeperRecordWithPayload(walletAddress) {\n        return this.fetchWithRetry(this.urlForWallet(walletAddress), {\n            method: 'GET',\n        }).then(async (response) => ({\n            state: GatekeeperRecordState[GatekeeperRecordState[response.status]],\n            payload: await response.json(),\n        }));\n    }\n    /**\n     * Polls the gatekeeper status until 2xx or 4xx is received except 404 for which it retries.\n     */\n    async pollGatekeeperStatus(walletAddress) {\n        const isTokenCreated = (code) => code === 200;\n        const isFailure = (code) => code !== 404 && code >= 400 && code < 500;\n        const pollRetryParams = Object.assign(Object.assign({}, this.defaultRetryParams), { retries: 5 * 30, retryOn: (attempt, retries, error, response) => attempt < retries &&\n                (!!error || !response || (!isTokenCreated(response.status) && !isFailure(response.status))), retryDelay: 2000 * testRetryMultipler() });\n        const pollingFetch = fetchBuilder(this.fetchImplementation, pollRetryParams);\n        const pollRes = pollingFetch(this.urlForWallet(walletAddress), {\n            method: 'HEAD',\n        });\n        return pollRes.then(({ status }) => status);\n    }\n    async requestGatewayTokenFromGatekeeper({ wallet, payload, proof }) {\n        // produce a signature that proves ownership of a wallet\n        logger.debug('requestGatewayTokenFromGatekeeper request', Object.assign(Object.assign({}, payload), { proof }));\n        // We only pass the wallet public key as part of the request if\n        // it was not passed as part of the presentation.\n        const body = Object.assign(Object.assign({}, payload), { proof, address: wallet.publicKey });\n        const gatewayTokenCreationRequest = Object.assign(Object.assign({}, body), { proof });\n        logger.debug('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', gatewayTokenCreationRequest);\n        const url = new URL(this.baseUrl);\n        this.addQueryParams(url);\n        return this.fetchWithRetry(url.toString(), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(gatewayTokenCreationRequest),\n        }).then((resp) => resp);\n    }\n    /**\n     * Tries to refresh a token.\n     * If it fails with a 5xx, handleFetchError will retry a number of times.\n     */\n    async refreshToken(gatewayTokenKey, walletPublicKey, proof, payload) {\n        logger.debug('refreshToken...', { gatewayTokenKey, payload });\n        logger.debug('Attempting to refresh the Gateway token');\n        return this.fetchWithRetry(this.urlForWallet(walletPublicKey), {\n            method: 'PATCH',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(Object.assign({ proof, request: 'refresh' }, payload)),\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}