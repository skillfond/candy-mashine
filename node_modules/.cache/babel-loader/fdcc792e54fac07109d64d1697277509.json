{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Test Mint\\\\metaplex\\\\js\\\\packages\\\\candy-machine-ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _slicedToArray from \"C:\\\\Test Mint\\\\metaplex\\\\js\\\\packages\\\\candy-machine-ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\slicedToArray.js\";\nimport _classCallCheck from \"C:\\\\Test Mint\\\\metaplex\\\\js\\\\packages\\\\candy-machine-ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Test Mint\\\\metaplex\\\\js\\\\packages\\\\candy-machine-ui\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\Test Mint\\\\metaplex\\\\js\\\\packages\\\\candy-machine-ui\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport fetchBuilder from 'fetch-retry-ts';\nimport { GatekeeperRecordState } from '../types';\nimport logger from '../logger';\nimport { getDefaultApiNumRetries } from '../config';\n\nvar testRetryMultipler = function testRetryMultipler() {\n  return parseFloat(process.env.TEST_RETRY_MULTIPLIER || '') || 1;\n};\n\nvar GatekeeperClient = /*#__PURE__*/function () {\n  function GatekeeperClient(gatekeeperClientConfig) {\n    _classCallCheck(this, GatekeeperClient);\n\n    this.baseUrl = gatekeeperClientConfig.baseUrl;\n    this.stage = gatekeeperClientConfig.stage;\n    this.queryParams = gatekeeperClientConfig.queryParams;\n    this.fetchImplementation = gatekeeperClientConfig.fetchImplementation || fetch; // By default retry on every 5xx or other Error (e.g. network failure):\n\n    this.defaultRetryParams = {\n      retries: gatekeeperClientConfig.numRetries || getDefaultApiNumRetries(this.stage),\n      retryOn: function retryOn(attempt, retries, error, response) {\n        return attempt < retries && (!!error || !response || response.status >= 500);\n      },\n      retryDelay: function retryDelay(attempt) {\n        return Math.pow(2, attempt) * 1000 * testRetryMultipler();\n      }\n    };\n    this.fetchWithRetry = fetchBuilder(this.fetchImplementation, this.defaultRetryParams);\n  }\n\n  _createClass(GatekeeperClient, [{\n    key: \"addQueryParams\",\n    value: function addQueryParams(url) {\n      if (!this.queryParams) return;\n      Object.entries(this.queryParams).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        url.searchParams.append(key, value);\n      });\n    }\n  }, {\n    key: \"urlForWallet\",\n    value: function urlForWallet(walletAddress) {\n      var url = new URL(\"\".concat(this.baseUrl, \"/\").concat(walletAddress));\n      this.addQueryParams(url);\n      return url.toString();\n    }\n  }, {\n    key: \"getGatekeeperRecordWithPayload\",\n    value: function () {\n      var _getGatekeeperRecordWithPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(walletAddress) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.fetchWithRetry(this.urlForWallet(walletAddress), {\n                  method: 'GET'\n                }).then( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(response) {\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.t0 = GatekeeperRecordState[GatekeeperRecordState[response.status]];\n                            _context.next = 3;\n                            return response.json();\n\n                          case 3:\n                            _context.t1 = _context.sent;\n                            return _context.abrupt(\"return\", {\n                              state: _context.t0,\n                              payload: _context.t1\n                            });\n\n                          case 5:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getGatekeeperRecordWithPayload(_x) {\n        return _getGatekeeperRecordWithPayload.apply(this, arguments);\n      }\n\n      return getGatekeeperRecordWithPayload;\n    }()\n    /**\n     * Polls the gatekeeper status until 2xx or 4xx is received except 404 for which it retries.\n     */\n\n  }, {\n    key: \"pollGatekeeperStatus\",\n    value: function () {\n      var _pollGatekeeperStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(walletAddress) {\n        var isTokenCreated, isFailure, pollRetryParams, pollingFetch, pollRes;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                isTokenCreated = function isTokenCreated(code) {\n                  return code === 200;\n                };\n\n                isFailure = function isFailure(code) {\n                  return code !== 404 && code >= 400 && code < 500;\n                };\n\n                pollRetryParams = Object.assign(Object.assign({}, this.defaultRetryParams), {\n                  retries: 5 * 30,\n                  retryOn: function retryOn(attempt, retries, error, response) {\n                    return attempt < retries && (!!error || !response || !isTokenCreated(response.status) && !isFailure(response.status));\n                  },\n                  retryDelay: 2000 * testRetryMultipler()\n                });\n                pollingFetch = fetchBuilder(this.fetchImplementation, pollRetryParams);\n                pollRes = pollingFetch(this.urlForWallet(walletAddress), {\n                  method: 'HEAD'\n                });\n                return _context3.abrupt(\"return\", pollRes.then(function (_ref4) {\n                  var status = _ref4.status;\n                  return status;\n                }));\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function pollGatekeeperStatus(_x3) {\n        return _pollGatekeeperStatus.apply(this, arguments);\n      }\n\n      return pollGatekeeperStatus;\n    }()\n  }, {\n    key: \"requestGatewayTokenFromGatekeeper\",\n    value: function () {\n      var _requestGatewayTokenFromGatekeeper = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n        var wallet, payload, proof, body, gatewayTokenCreationRequest, url;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                wallet = _ref5.wallet, payload = _ref5.payload, proof = _ref5.proof;\n                // produce a signature that proves ownership of a wallet\n                logger.debug('requestGatewayTokenFromGatekeeper request', Object.assign(Object.assign({}, payload), {\n                  proof: proof\n                })); // We only pass the wallet public key as part of the request if\n                // it was not passed as part of the presentation.\n\n                body = Object.assign(Object.assign({}, payload), {\n                  proof: proof,\n                  address: wallet.publicKey\n                });\n                gatewayTokenCreationRequest = Object.assign(Object.assign({}, body), {\n                  proof: proof\n                });\n                logger.debug('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', gatewayTokenCreationRequest);\n                url = new URL(this.baseUrl);\n                this.addQueryParams(url);\n                return _context4.abrupt(\"return\", this.fetchWithRetry(url.toString(), {\n                  method: 'POST',\n                  headers: {\n                    'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify(gatewayTokenCreationRequest)\n                }).then(function (resp) {\n                  return resp;\n                }));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function requestGatewayTokenFromGatekeeper(_x4) {\n        return _requestGatewayTokenFromGatekeeper.apply(this, arguments);\n      }\n\n      return requestGatewayTokenFromGatekeeper;\n    }()\n    /**\n     * Tries to refresh a token.\n     * If it fails with a 5xx, handleFetchError will retry a number of times.\n     */\n\n  }, {\n    key: \"refreshToken\",\n    value: function () {\n      var _refreshToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(gatewayTokenKey, walletPublicKey, proof, payload) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                logger.debug('refreshToken...', {\n                  gatewayTokenKey: gatewayTokenKey,\n                  payload: payload\n                });\n                logger.debug('Attempting to refresh the Gateway token');\n                return _context5.abrupt(\"return\", this.fetchWithRetry(this.urlForWallet(walletPublicKey), {\n                  method: 'PATCH',\n                  headers: {\n                    'Content-Type': 'application/json'\n                  },\n                  body: JSON.stringify(Object.assign({\n                    proof: proof,\n                    request: 'refresh'\n                  }, payload))\n                }));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function refreshToken(_x5, _x6, _x7, _x8) {\n        return _refreshToken.apply(this, arguments);\n      }\n\n      return refreshToken;\n    }()\n  }]);\n\n  return GatekeeperClient;\n}();\n\nexport { GatekeeperClient as default };","map":{"version":3,"sources":["C:/Test Mint/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/utils/gatekeeperClient.js"],"names":["fetchBuilder","GatekeeperRecordState","logger","getDefaultApiNumRetries","testRetryMultipler","parseFloat","process","env","TEST_RETRY_MULTIPLIER","GatekeeperClient","gatekeeperClientConfig","baseUrl","stage","queryParams","fetchImplementation","fetch","defaultRetryParams","retries","numRetries","retryOn","attempt","error","response","status","retryDelay","fetchWithRetry","url","Object","entries","forEach","key","value","searchParams","append","walletAddress","URL","addQueryParams","toString","urlForWallet","method","then","json","state","payload","isTokenCreated","code","isFailure","pollRetryParams","assign","pollingFetch","pollRes","wallet","proof","debug","body","address","publicKey","gatewayTokenCreationRequest","headers","JSON","stringify","resp","gatewayTokenKey","walletPublicKey","request"],"mappings":"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","sourcesContent":["import fetchBuilder from 'fetch-retry-ts';\nimport { GatekeeperRecordState } from '../types';\nimport logger from '../logger';\nimport { getDefaultApiNumRetries } from '../config';\nconst testRetryMultipler = () => parseFloat(process.env.TEST_RETRY_MULTIPLIER || '') || 1;\nexport default class GatekeeperClient {\n    constructor(gatekeeperClientConfig) {\n        this.baseUrl = gatekeeperClientConfig.baseUrl;\n        this.stage = gatekeeperClientConfig.stage;\n        this.queryParams = gatekeeperClientConfig.queryParams;\n        this.fetchImplementation = gatekeeperClientConfig.fetchImplementation || fetch;\n        // By default retry on every 5xx or other Error (e.g. network failure):\n        this.defaultRetryParams = {\n            retries: gatekeeperClientConfig.numRetries || getDefaultApiNumRetries(this.stage),\n            retryOn: (attempt, retries, error, response) => attempt < retries && (!!error || !response || response.status >= 500),\n            retryDelay: (attempt) => 2 ** attempt * 1000 * testRetryMultipler(),\n        };\n        this.fetchWithRetry = fetchBuilder(this.fetchImplementation, this.defaultRetryParams);\n    }\n    addQueryParams(url) {\n        if (!this.queryParams)\n            return;\n        Object.entries(this.queryParams).forEach(([key, value]) => {\n            url.searchParams.append(key, value);\n        });\n    }\n    urlForWallet(walletAddress) {\n        const url = new URL(`${this.baseUrl}/${walletAddress}`);\n        this.addQueryParams(url);\n        return url.toString();\n    }\n    async getGatekeeperRecordWithPayload(walletAddress) {\n        return this.fetchWithRetry(this.urlForWallet(walletAddress), {\n            method: 'GET',\n        }).then(async (response) => ({\n            state: GatekeeperRecordState[GatekeeperRecordState[response.status]],\n            payload: await response.json(),\n        }));\n    }\n    /**\n     * Polls the gatekeeper status until 2xx or 4xx is received except 404 for which it retries.\n     */\n    async pollGatekeeperStatus(walletAddress) {\n        const isTokenCreated = (code) => code === 200;\n        const isFailure = (code) => code !== 404 && code >= 400 && code < 500;\n        const pollRetryParams = Object.assign(Object.assign({}, this.defaultRetryParams), { retries: 5 * 30, retryOn: (attempt, retries, error, response) => attempt < retries &&\n                (!!error || !response || (!isTokenCreated(response.status) && !isFailure(response.status))), retryDelay: 2000 * testRetryMultipler() });\n        const pollingFetch = fetchBuilder(this.fetchImplementation, pollRetryParams);\n        const pollRes = pollingFetch(this.urlForWallet(walletAddress), {\n            method: 'HEAD',\n        });\n        return pollRes.then(({ status }) => status);\n    }\n    async requestGatewayTokenFromGatekeeper({ wallet, payload, proof }) {\n        // produce a signature that proves ownership of a wallet\n        logger.debug('requestGatewayTokenFromGatekeeper request', Object.assign(Object.assign({}, payload), { proof }));\n        // We only pass the wallet public key as part of the request if\n        // it was not passed as part of the presentation.\n        const body = Object.assign(Object.assign({}, payload), { proof, address: wallet.publicKey });\n        const gatewayTokenCreationRequest = Object.assign(Object.assign({}, body), { proof });\n        logger.debug('requestGatewayTokenFromGatekeeper Requesting a new gatekeeper token...', gatewayTokenCreationRequest);\n        const url = new URL(this.baseUrl);\n        this.addQueryParams(url);\n        return this.fetchWithRetry(url.toString(), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(gatewayTokenCreationRequest),\n        }).then((resp) => resp);\n    }\n    /**\n     * Tries to refresh a token.\n     * If it fails with a 5xx, handleFetchError will retry a number of times.\n     */\n    async refreshToken(gatewayTokenKey, walletPublicKey, proof, payload) {\n        logger.debug('refreshToken...', { gatewayTokenKey, payload });\n        logger.debug('Attempting to refresh the Gateway token');\n        return this.fetchWithRetry(this.urlForWallet(walletPublicKey), {\n            method: 'PATCH',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(Object.assign({ proof, request: 'refresh' }, payload)),\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}