{"ast":null,"code":"import { useCallback } from 'react';\nimport { statusFromToken } from '../useReducer/utils';\nimport { getRefreshIntervalMs } from '../config';\nimport logger from '../logger';\nimport { GatewayStatus, RefreshTokenState } from '../types';\nexport var reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          refreshIntervalId: action.refreshIntervalId,\n          walletToRefresh: action.walletToRefresh,\n          refreshTokenState: RefreshTokenState.CHECK_TOKEN_EXPIRATION\n        });\n      }\n\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          gatewayStatus: GatewayStatus.REFRESH_TOKEN_REQUIRED,\n          refreshTokenState: RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: RefreshTokenState.COMPLETED,\n          gatewayStatus: statusFromToken(state, state.gatewayToken)\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: GatewayStatus.COLLECTING_USER_INFORMATION\n        });\n      }\n\n    case 'refresh_clear_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: undefined\n      });\n\n    case 'refresh_set_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: action.refreshIntervalId\n      });\n\n    default:\n      return state;\n  }\n};\n\nvar useRefresh = function useRefresh(_ref, state, dispatch) {\n  var stage = _ref.stage,\n      gatekeeperClient = _ref.gatekeeperClient;\n  var refreshIntervalId = state.refreshIntervalId,\n      gatewayToken = state.gatewayToken;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger.debug(\"[useRefresh] \".concat(message), obj);\n  };\n\n  var logError = function logError(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger.error(\"[useRefresh] \".concat(message), obj);\n  };\n  /**\n   * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n   * event, triggering the refreshFlow\n   */\n\n\n  var setRefreshPoll = useCallback(function (connectedWallet) {\n    if (!refreshIntervalId) {\n      var interval = setInterval(function () {\n        dispatch({\n          type: 'refresh_status_check',\n          refreshIntervalId: interval,\n          walletToRefresh: connectedWallet\n        });\n      }, getRefreshIntervalMs(stage)); // this will be cleared on completion\n      // We need to know that the interval was set even if it has not fired yet.\n      // to avoid setting duplicate intervals.\n\n      dispatch({\n        type: 'refresh_set_interval',\n        refreshIntervalId: interval\n      });\n      logger.debug('setRefreshPoll setInterval', getRefreshIntervalMs(stage));\n    }\n  }, [refreshIntervalId, stage]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  var refreshTokenWithProof = useCallback(function (useWallet) {\n    return function (_ref2) {\n      var proof = _ref2.proof,\n          payload = _ref2.payload;\n      return new Promise(function (resolve, reject) {\n        logDebug('Refresh token with proof', proof);\n\n        if (proof && gatewayToken) {\n          dispatch({\n            type: 'refresh_with_powo_in_progress'\n          });\n          gatekeeperClient().refreshToken(gatewayToken.identifier, useWallet.publicKey, proof, payload).then(function () {\n            resolve();\n          }).catch(function (error) {\n            logError('Error refreshing token with proof', error);\n            reject(error);\n          });\n        }\n      });\n    };\n  }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n  return {\n    setRefreshPoll: setRefreshPoll,\n    refreshTokenWithProof: refreshTokenWithProof\n  };\n};\n\nexport default useRefresh;","map":{"version":3,"sources":["F:/SitePortfolio/skillfond/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"names":["useCallback","statusFromToken","getRefreshIntervalMs","logger","GatewayStatus","RefreshTokenState","reducer","state","action","type","Object","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","refreshIntervalId","walletToRefresh","refreshTokenState","CHECK_TOKEN_EXPIRATION","gatewayStatus","REFRESH_TOKEN_REQUIRED","IN_PROGRESS","COMPLETED","gatewayToken","renderIframe","iframeMinimized","COLLECTING_USER_INFORMATION","useRefresh","dispatch","stage","gatekeeperClient","logDebug","message","obj","debug","logError","error","setRefreshPoll","connectedWallet","interval","setInterval","refreshTokenWithProof","useWallet","proof","payload","Promise","resolve","reject","refreshToken","identifier","publicKey","then","catch"],"mappings":"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","sourcesContent":["import { useCallback } from 'react';\nimport { statusFromToken } from '../useReducer/utils';\nimport { getRefreshIntervalMs } from '../config';\nimport logger from '../logger';\nimport { GatewayStatus, RefreshTokenState } from '../types';\nexport const reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, refreshIntervalId: action.refreshIntervalId, walletToRefresh: action.walletToRefresh, refreshTokenState: RefreshTokenState.CHECK_TOKEN_EXPIRATION });\n        }\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { gatewayStatus: GatewayStatus.REFRESH_TOKEN_REQUIRED, refreshTokenState: RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: RefreshTokenState.COMPLETED, gatewayStatus: statusFromToken(state, state.gatewayToken) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: GatewayStatus.COLLECTING_USER_INFORMATION });\n        }\n        case 'refresh_clear_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: undefined });\n        case 'refresh_set_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: action.refreshIntervalId });\n        default:\n            return state;\n    }\n};\nconst useRefresh = ({ stage, gatekeeperClient }, state, dispatch) => {\n    const { refreshIntervalId, gatewayToken } = state;\n    const logDebug = (message, obj = null) => logger.debug(`[useRefresh] ${message}`, obj);\n    const logError = (message, obj = null) => logger.error(`[useRefresh] ${message}`, obj);\n    /**\n     * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n     * event, triggering the refreshFlow\n     */\n    const setRefreshPoll = useCallback((connectedWallet) => {\n        if (!refreshIntervalId) {\n            const interval = setInterval(() => {\n                dispatch({\n                    type: 'refresh_status_check',\n                    refreshIntervalId: interval,\n                    walletToRefresh: connectedWallet,\n                });\n            }, getRefreshIntervalMs(stage)); // this will be cleared on completion\n            // We need to know that the interval was set even if it has not fired yet.\n            // to avoid setting duplicate intervals.\n            dispatch({\n                type: 'refresh_set_interval',\n                refreshIntervalId: interval,\n            });\n            logger.debug('setRefreshPoll setInterval', getRefreshIntervalMs(stage));\n        }\n    }, [refreshIntervalId, stage]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshTokenWithProof = useCallback((useWallet) => ({ proof, payload }) => {\n        return new Promise((resolve, reject) => {\n            logDebug('Refresh token with proof', proof);\n            if (proof && gatewayToken) {\n                dispatch({ type: 'refresh_with_powo_in_progress' });\n                gatekeeperClient()\n                    .refreshToken(gatewayToken.identifier, useWallet.publicKey, proof, payload)\n                    .then(() => {\n                    resolve();\n                })\n                    .catch((error) => {\n                    logError('Error refreshing token with proof', error);\n                    reject(error);\n                });\n            }\n        });\n    }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n    return {\n        setRefreshPoll,\n        refreshTokenWithProof,\n    };\n};\nexport default useRefresh;\n"]},"metadata":{},"sourceType":"module"}